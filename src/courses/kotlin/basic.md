# Kotlin 基礎語法

~~~admonish note title="作者"
D1stance (吳翰平)
~~~

在開始寫程式之前，我們要先認識基礎的東西——`變數`。變數是用來儲存資料的容器，讓我們可以在程式中使用和操作這些資料。

## 變數

在 Kotlin 中，變數可以使用 `val` 或 `var` 來宣告：  
- `val` 用來宣告不可變的變數（類似於常數），一旦賦值後就不能再改變，是為 `value` 的縮寫。  
- `var` 用來宣告可變的變數，可以在後續的程式中修改其值，是為 `variable` 的縮寫。

```kotlin
val n = 10 // 不可變變數
var m = 20 // 可變變數
m = 30 // 可以修改 m 的值
```

變數的命名規則如下：

* 只能包含字母、數字、底線(\_) ，數字不能作為開頭。
* 不能使用 Kotlin 的保留字。
* 命名應該具有描述性，能夠清楚表達變數的用途。

> **補充說明：** Kotlin 的變數名稱允許使用 Unicode 字元，也就是你可以用中文甚至 emoji 當變數名，但在競賽中建議還是使用英文與數字、底線，以維持通用性與可讀性。

## 基本資料型別

Kotlin 支援多種基本資料型別，包括：

* `Int`：整數型別，32-bit 有號整數。 (範圍 $-2,147,483,648$ 到 $2,147,483,647$)
* `Double`：雙精度浮點數型別，64-bit 浮點數。
* `String`：字串型別。
* `Boolean`：布林型別（`true` 或 `false`）。
* `Char`：字元型別，表示單一字元。
* `Long`：長整數型別，64-bit 有號整數。 (範圍 $-9,223,372,036,854,775,808$ 到 $9,223,372,036,854,775,807$)

這些資料型別可以用來儲存不同類型的資料，並且可以進行各種運算。

```kotlin
val age: Int = 25 // 整數
val height: Double = 1.75 // 雙精度浮點數
val name: String = "D1stance" // 字串
val isStudent: Boolean = true // 布林值
val initial: Char = 'D' // 字元
val population: Long = 7000000000 // 長整數
```

> **競賽小提醒：**
> 在競程中，如果你需要處理超出 `Int` 範圍的數字（約 ±21 億），請使用 `Long`。另外，Kotlin 的整數運算不會自動溢位檢查，請留意運算結果是否超出範圍。

如果你不指定資料型別，Kotlin 會自動推斷變數的型別：

```kotlin
val city = "Taipei" // Kotlin 會推斷 city 為 String 型別
val temperature = 25.5 // Kotlin 會推斷 temperature 為 Double型別
```

> Kotlin 的型別推斷功能可以讓程式更簡潔，但在複雜情況下建議明確指定型別，避免因推斷錯誤導致的問題。

## 輸出入

在競賽中，輸入輸出效率非常重要，因為很多時候資料量很大，使用簡單的 `readLine()` 和 `println()` 可能會導致效能瓶頸。

如果我們不只是直接給定變數的值，而是需要從使用者那裡獲取輸入，可以使用 `readLn()` 函數來讀取輸入：

```kotlin
println("請輸入你的名字：")
val name = readLn()
println("你好，$name")
```


`println()` 函數用來輸出訊息，同時加上換行，但像是 `print()` 則不會換行。
而 `readLn()` 函數則會等待使用者輸入一行文字，並將其作為字串返回。
最後，我們可以在 `println()`, `print()` 中使用 `$` 符號來插入變數的值，例如 `$name` 會被替換為變數 `name` 的值。

### 讀取數字輸入

如果今天我們需要從使用者那裡獲取數字輸入，則可以使用 `readLn()` 函數來讀取輸入，並將其轉換為所需的資料型別：

```kotlin
println("請輸入你的年齡：")
val age = readLn().toInt() // 將輸入的字串轉換為整數
println("你的年齡是 $age 歲。")
```

這裡我們使用 `toInt()` 函數將輸入的字串轉換為整數型別。Kotlin 提供了許多類似的轉換函數，例如 `toDouble()`, `toLong()` 等，可以根據需要進行資料型別的轉換。

### 多變數同時輸入

假設單行內有多個變數需要輸入，可以使用 `readLn()` 讀取整行輸入，然後使用 `split()` 函數將其分割成多個部分：

```kotlin
val (s1, s2, s3) = readLn().split(" ").map { it.toInt() }
println("你輸入的三個數字是：$s1, $s2, $s3")
```

這裡我們使用 `split(" ")` 將輸入的字串按空格分割成多個部分，然後使用 `map { it.toInt() }` 將每個部分轉換為整數。最後，我們將這些整數賦值給變數 `s1`, `s2`, `s3`。

> **效能提升技巧：**
> 如果輸入資料量特別大，可以改用 `BufferedReader` 來加快讀取速度，稍後章節會示範更高效的輸入輸出寫法。

### 程式入口點：main 函數

那麼以上這些程式碼應該從哪裡開始執行呢？在 Kotlin 中，我們需要一個 `main` 函數作為程式的入口點：

```kotlin
fun main() {
    // your code here
}
```

在 `main` 函數中，我們可以放置我們的程式碼，這樣當我們執行程式時，Kotlin 會從 `main` 函數開始執行，
逐行進行執行，直到程式結束。

範例程式碼中 `//` 後面的部分是註解，用來說明程式碼的作用，這些註解不會被執行，只是用來幫助我們理解程式碼，
如果需要多行註解，可以使用 `/* ... */` 的形式。

```kotlin
fun main() {
    println("請輸入你的名字：")
    val name = readLn()
    println("你好，$name！")
    println("請輸入你的年齡：")
    val age = readLn().toInt()
    println("你的年齡是 $age 歲。")
}
```

~~~admonish info title="例題"
請寫一個程式，要求使用者輸入兩個整數，然後輸出它們的和。
~~~

~~~admonish note title="解答" collapsible=true
```kotlin
fun main() {
    val (num1, num2) = readLn().split(" ").map { it.toInt() }
    println("${num1 + num2}")
}
```
~~~

### 使用 BufferedReader 與 BufferedWriter 提升輸入輸出效率

但是這樣的寫法跟 C++ 的輸出入緩衝有點類似，我們會總是等待使用者輸入完畢後才會繼續執行程式。
這在某些情況下可能會導致程式的執行效率降低，特別是在需要頻繁輸入輸出的情況下，但是在競賽程式中，我們通常只會比較最後輸出的結果，
所以其實我們可以不用一邊輸入一邊輸出，而是等到所有輸入都完成後再一次性輸出結果。

為了達到這個目的，我們引入了 `BufferedReader` 和 `BufferedWriter` 這兩個類別。`BufferedReader` 用來讀取輸入，而 `BufferedWriter` 用來輸出結果。
這樣可以提高程式的執行效率，特別是在需要大量輸入輸出的情況下。

```kotlin
import java.io.*

// 使用 BufferedReader 和 BufferedWriter 來提高輸入輸出效率
val br = BufferedReader(InputStreamReader(System.`in`))
val bw = BufferedWriter(OutputStreamWriter(System.`out`))
// 讀取一行輸入
fun readLine() = br.readLine()!!
fun write(x: Any) = bw.write(x.toString())
fun writeln(x: Any) = bw.write("$x\n")
fun flush() = bw.flush()

fun main() {
    // 讀取兩個整數
    val (num1, num2) = readLine().split(" ").map { it.toInt() }
    // 輸出它們的和
    writeln(num1 + num2)
    flush() // 確保所有輸出都被寫入
}
```

這樣的寫法可以讓我們在輸入完之後，只有呼叫 `flush()` 才會將所有輸出寫入，這樣可以提高程式的執行效率。

你可能比較會疑惑的是為什麼 `readLine()` 後面要加上 `!!`，這是因為 `readLine()` 可能會返回 `null`，
而 `Kotlin` 是一個注重安全的語言，在競程中我們通常會安心的覺得出題者不會給我們不合法的輸入，
所以我們可以使用 `!!` 來告訴編譯器我們確定這個值不會是 `null`。

但是原本教的 `readLn()` 不會回傳 `null`。

---

## 變數基礎運算

### 五則運算

在 Kotlin 中，我們可以使用基本的算術運算符來進行數學計算。這些運算符包括：

* `+`：加法
* `-`：減法
* `*`：乘法
* `/`：除法
* `%`：取餘數

這些運算符可以用來對變數進行基本的數學運算。

```kotlin
val a = 10
val b = 3
val sum = a + b // 加法
val difference = a - b // 減法
val product = a * b // 乘法
val quotient = a / b // 除法
val remainder = a % b // 取餘數
writeln("和：$sum, 差：$difference, 積：$product, 商：$quotient, 餘數：$remainder")
```

> **注意：**
> 在 Kotlin 中，整數除法會直接丟掉小數部分，等同於向零捨去。如果需要得到浮點數結果，請使用 `Double` 或 `Float`，或將整數轉為浮點數後再計算。

### 自運算

有時候我們會對變數自己做運算，例如將變數的值加上某個數字。Kotlin 提供了簡潔的自運算符：
```kotlin
var x = 5
x += 2 // 等同於 x = x + 2
x -= 3 // 等同於 x = x - 3
x *= 4 // 等同於 x = x * 4
x /= 2 // 等同於 x = x / 2
x %= 3 // 等同於 x = x % 3
```

這樣可以讓程式碼更簡潔，避免重複寫變數名稱。

#### 遞增遞減

Kotlin 也支援遞增和遞減運算符：

```kotlin
var y = 10
y++ // 遞增，等同於 y = y + 1
y-- // 遞減，等同於 y = y - 1
```

遞增跟遞減運算子還有前置和後置兩種形式：

```kotlin
var z = 5
println(++z) // 前置遞增，先增加再輸出，輸出 6
println(z++) // 後置遞增，先輸出再增加，輸出 6
println(z)   // 現在 z 的值是 7
```

可以根據使用情況選擇前置或後置形式。前置形式會先改變變數的值再使用，而後置形式則是先使用變數的值再改變。

### 位元運算

在講位元運算之前，我們先來了解一下什麼是位元。位元（bit）是計算機中最小的資料單位，它可以是 0 或 1，
位元運算是將數字透過二進位的視角來進行運算。

#### 二進位

二進位是計算機使用的數字系統，它只使用兩個數字：0 和 1。每個位元代表一個二進位位，從右到左依次代表 2 的 0 次方、1 次方、2 次方等。
例如，二進位數字 `1011` 可以表示為：

* $1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 1 \times 2^0 = 8 + 0 + 2 + 1 = 11$

其實我們平常使用的十進位數字系統也是一樣的道理，只是十進位使用的是 0 到 9 的數字。

例如，十進位數字 `123` 可以表示為：

* $1 \times 10^2 + 2 \times 10^1 + 3 \times 10^0 = 100 + 20 + 3 = 123$

#### 位元運算符

Kotlin 提供了幾種位元運算符來對整數進行位元運算：

* `shl`：左移位元
* `shr`：右移位元
* `and`：位元與運算
* `or`：位元或運算
* `xor`：位元異或運算
* `inv`：位元取反運算

我們先講講簡單的 `and`、`or`、`xor` 和 `inv`。

##### 位元與運算（`and`）

位元與運算是將兩個數字的每個位元進行比較，只有當兩個位元都是 1 時，結果才是 1，否則結果是 0。

```kotlin
val a = 0b1100 // 二進位表示的 12
val b = 0b1010 // 二進位表示的 10
val result = a and b // 位元與運算
writeln("位元與運算結果：${result.toString(2)}") // 輸出 1000
```

##### 位元或運算（`or`）

位元或運算是將兩個數字的每個位元進行比較，只要有一個位元是 1，結果就是 1，否則結果是 0。

```kotlin
val a = 0b1100 // 二進位表示的 12
val b = 0b1010 // 二進位表示的 10
val result = a or b // 位元或運算
writeln("位元或運算結果：${result.toString(2)}") // 輸出 1110
```

##### 位元異或運算（`xor`）

位元異或運算是將兩個數字的每個位元進行比較，當兩個位元不同時，結果是 1，否則結果是 0。

```kotlin
val a = 0b1100 // 二進位表示的 12
val b = 0b1010 // 二進位表示的 10
val result = a xor b // 位元異或運算
writeln("位元異或運算結果：${result.toString(2)}") // 輸出 0110
```

##### 位元取反運算（`inv`）

位元取反運算是將數字的每個位元進行取反操作，0 變成 1，1 變成 0。

```kotlin
val a = 0b1100 // 二進位表示的 12
val result = a.inv() // 位元取反運算
writeln("位元取反運算結果：${result.toString(2)}") // 輸出 0011
```

這裡 `toString(2)` 是將數字轉換為二進位字串表示。

##### 位元移位運算

比起上面的位元運算，位元移位運算更加的複雜，但它們在某些情況下非常有用，特別是在需要快速計算的情況下。

現在有一個數字 $a = 1100_{(2)}$，我們可以使用 `shl` 和 `shr` 來進行位元移位運算。

使用 `shl`（左移位元）可以將數字的位元向左移動指定的位數假設 `a shl 2`，這會將 `a` 的位元向左移動兩位，結果是 $110000_{(2)}$，
相當於把數字乘以 $2^2 = 4$。

```kotlin
val a = 0b1100 // 二進位表示的 12
val result = a shl 2 // 左移兩位
writeln("左移兩位結果：${result.toString(2)}") // 輸出 110000
```

使用 `shr`（右移位元）可以將數字的位元向右移動指定的位數假設 `a shr 2`，這會將 `a` 的位元向右移動兩位，結果是 $0011_{(2)}$，
相當於把數字除以 $2^2 = 4$。

```kotlin
val a = 0b1100 // 二進位表示的 12
val result = a shr 2 // 右移兩位
writeln("右移兩位結果：${result.toString(2)}") // 輸出 0011
```


## 條件判斷

在程式中，我們經常需要根據不同的條件來執行不同的程式碼。Kotlin 提供了 `if` 和 `when` 兩種主要的條件判斷語句。

### if 語句

當條件滿足的時候，才會執行區塊內的程式碼

那麼要怎麼撰寫條件判斷呢？我們需要以下這些邏輯運算子：
- `==`：等於
- `!=`：不等於
- `<`：小於
- `<=`：小於等於
- `>`：大於
- `>=`：大於等於

上面這些運算子可以用來比較兩個值，並返回布林值 `true` 或 `false`。

Kotlin 還有用來判斷是否在同一個記憶體位置的運算子 `===` 和 `!==`，這在比較物件時特別有用。

假設有多個條件，我們就需要使用 `&&` （邏輯與）和 `||`（邏輯或）來組合條件：
- `&&`：當兩個條件都為 `true` 時，結果才為 `true`。
- `||`：當至少一個條件為 `true` 時，結果為 `true`。

也可以加入 `!`（邏輯非）來反轉條件的結果。

當只有一個條件時，可以使用 `if` 語句來判斷：

```kotlin
val age = 18
if (age >= 18) {
    writeln("你已經成年了。")
}
```

如果需要在條件不滿足時執行其他程式碼，可以使用 `else`：
```kotlin
val age = 16
if (age >= 18) {
    writeln("你已經成年了。")
} else {
    writeln("你還未成年。")
}
``` 

如果有多個條件需要判斷，可以使用 `else if`：
```kotlin
val score = 85
if (score >= 90) {
    writeln("優秀")
} else if (score >= 80) {
    writeln("良好")
} else if (score >= 70) {
    writeln("普通")
} else {
    writeln("需要加油")
}
``` 

這樣就完成了基本的條件判斷。

### when 語句

`when` 語句是一種更靈活的條件判斷方式，可以用來替代多個 `if-else` 語句。它可以根據不同的條件執行不同的程式碼塊。

```kotlin
val day = 3
when (day) {
    1 -> writeln("今天是星期一")
    2 -> writeln("今天是星期二")
    3 -> writeln("今天是星期三")
    4 -> writeln("今天是星期四")
    5 -> writeln("今天是星期五")
    6 -> writeln("今天是星期六")
    7 -> writeln("今天是星期日")    
    else -> writeln("無效的日期")
}
```

如果需要判斷多個條件，可以使用 `when` 的其他形式：
```kotlin
val score = 85
when {
    score >= 90 -> writeln("優秀")
    score >= 80 -> writeln("良好")
    score >= 70 -> writeln("普通")
    else -> writeln("需要加油")
}
```

這樣就可以根據不同的條件執行不同的程式碼，
相當於 C/C++ 的 `switch` 語句，但 `when` 更加靈活，可以處理更複雜的條件。


## 變數的作用域

在 Kotlin 中，變數的作用域是指變數可以被訪問的範圍。變數的作用域取決於它們的宣告位置。
- **全域變數**：在 `main` 函數外部宣告的變數，可以在整個程式中訪問。
- **區域變數**：在 `main` 函數內部宣告的變數，只能在該函數內部訪問。
- **區塊變數**：在特定區塊（如 `if` 或 `when` 語句）內部宣告的變數，只能在該區塊內部訪問。

```kotlin
val globalVar = "全域變數"
fun main() {
    val localVar = "區域變數"
    if (true) {
        val blockVar = "區塊變數"
        writeln("訪問區塊變數：$blockVar")
    }
    writeln("訪問全域變數：$globalVar")
    writeln("訪問區域變數：$localVar")
    // writeln(blockVar) // 這裡會報錯，因為 blockVar 只在 if 區塊內部可見
}
```

通常而言，我們會盡量避免使用全域變數，因為全域變數可能會導致程式的可讀性和可維護性降低，
尤其整個程式碼都可以訪問全域變數，這可能會導致意外的錯誤。

只有全域的變數可以加上 `const` 修飾符，這樣可以在編譯時期就確定變數的值，並且這個變數的值在整個程式中都是不變的。

```kotlin
const val PI = 3.14159 // 全域常數
fun main() {
    writeln("圓周率的值是：$PI")
}
```

一個變數如果被宣告為 `const`，那麼它必須在編譯時期就能確定其值，並且這個值在整個程式中都是不變的，
這樣可以提高程式的性能，因為編譯器可以在編譯時期就將這個值替換到程式碼中，而不需要在執行時期進行計算。

## 小結
在這一章中，我們學習了 Kotlin 的基本語法，包括變數的宣告、基本資料型別、輸出入操作以及條件判斷語句。
這些基礎知識是學習 Kotlin 的重要基石，掌握了這些內容，我們就可以開始編寫更複雜的程式了。
接下來，我們將進一步學習 Kotlin 的控制結構和迴圈，這將幫助我們更好地控制程式的執行流程。
