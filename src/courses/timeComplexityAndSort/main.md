# 時間複雜度排序與二分搜尋法

## 時間複雜度

一個演算法是解決問題的一連串步驟，也許一個問題有很多不同的解法，所以我們會衡量一個演算法的好壞，通常會用時間複雜度 (Time Complexity) 或者實作的難度來衡量。

時間複雜度是用來描述演算法在執行時所需的時間，通常會用大 $O$ 符號 (Big-O Notation) 來表示。大 O 符號描述的是演算法在輸入規模增加時，執行時間的增長趨勢。

### Big-O Notation

$n_0 \in \mathbb{N}, \forall n \geq n_0, \exists c > 0, \text{使得} f(n) \leq c \cdot g(n)$
則 $f(n) \in O(g(n))$

用白話文就是說，在 $n$ 達到某個數字 $n_0$ 之後，$f(n)$ 都會被 $g(n)$ 乘上一個常數 $c$ 所限制住，
我們就可以用 $O(g(n))$ 來表示 $f(n)$ 的時間複雜度。

舉例來說，假設有一個演算法的時間複雜度是 $f(n) = 3n^2 + 2n + 1$，我們可以說這個演算法的時間複雜度是 $O(n^2)$，因為當 $n$ 足夠大時，$3n^2 + 2n + 1$ 可以被 $4n^2$ 所限制住 (這裡 $c=4$，$n_0=2$)。

用更簡單的觀點來看，就是我們把時間複雜度的公式中，忽略掉常數項和低階項，只保留最高階的項，這樣就能更清楚地看到演算法在處理大量資料時的效率。

**Sample Code**

```kotlin
fun printPairs(arr: Array<Int>, x: Int) {
    val n = arr.size
    for (i in 0 until n) {
        for (j in 0 until n) {
            if (arr[i] + arr[j] == x) {
                println("Pair found: (${arr[i]}, ${arr[j]})")
            }
        }
    }
}
```

這是一個用於尋找陣列中兩個數字和為特定值的程式碼。這個程式碼的時間複雜度是 $O(n^2)$，因為它有兩層迴圈，每一層迴圈都會遍歷整個陣列。

像是上一堂課介紹到的費波那契數列 (Fibonacci Sequence) 的遞迴解法，因為我們每次都會有兩個新的分支，
最多會有 $n$ 層的呼叫，所以時間複雜度是指數級的 $O(2^n)$。

雖然 $f(n) = n^2$ 時，我們稱呼 $f(n) \in O(2^n)$ 也沒有問題，但通常我們會希望能找到一個更接近實際情況的時間複雜度來描述演算法的效率，
在數學上定義為 $f(n) \in \Theta(g(n))$，意思是說 $f(n)$ 和 $g(n)$ 在漸近行為上是相同的。

不過在這裡我們主要還是會使用大 O 符號來描述時間複雜度，因為它比較常見且容易理解。

## 排序演算法

假設現在有 $n$ 個數字，我們想要把它們從小到大排序，因為排序之後可以幫助我們更快解決其他問題，例如找到重複的數字、尋找最大或最小值等等。

所以接下來會介紹幾種常見的排序演算法，並且分析它們的時間複雜度。

### Selection Sort

每一輪從未排序的數字中選出最小的數字，然後把它放到前面。

| index | 0 | 1 | 2 | 3 | 4 |
|-------|---|---|---|---|---|
| value | 64| 25| 12| 22| 11|

第一輪，我們先進行 $64, 25$ 的比較，發現 $25$ 比較小，接著拿 $25$ 跟 $12$ 比較，發現 $12$ 比較小，接著拿 $12$ 跟 $22$ 比較，發現 $12$ 比較小，最後拿 $12$ 跟 $11$ 比較，發現 $11$ 比較小，所以我們把 $11$ 放到最前面。

| index | 0 | 1 | 2 | 3 | 4 |
|-------|---|---|---|---|---|
| value | 11| 25| 12| 22| 64|

第二輪，我們從剩下的數字繼續比較，從 $25, 12$ 開始，最後會把 $12$ 放到第二個位置。

| index | 0 | 1 | 2 | 3 | 4 |
|-------|---|---|---|---|---|
| value | 11| 12| 25| 22| 64|

第三輪，我們從剩下的數字繼續比較，從 $25, 22$ 開始，最後會把 $22$ 放到第三個位置，以此類推，直到所有數字都排序完成。

| index | 0 | 1 | 2 | 3 | 4 |
|-------|---|---|---|---|---|
| value | 11| 12| 22| 25| 64|

時間複雜度分析：

因為第一輪需要比較 $n - 1$ 次，第二輪需要比較 $n - 2$ 次，以此類推，總共需要比較的次數是：
$$(n - 1) + (n - 2) + ... + 1 = \frac{n(n - 1)}{2}$$

所以時間複雜度是 $O(n^2)$。

### Bubble Sort

重複地走訪過要排序的數列，一次比較兩個元素，如果它們的順序錯誤就把它們交換過來。這個過程會重複進行，直到沒有需要交換的元素為止。

| index | 0 | 1 | 2 | 3 | 4 |
|-------|---|---|---|---|---|
| value | 64| 34| 25| 12| 22|

第一輪，我們從第一個元素開始，依次比較相鄰的兩個元素，如果前一個元素比後一個元素大，就交換它們的位置。經過第一輪後，最大的元素會被移動到最後一個位置。

| index | 0 | 1 | 2 | 3 | 4 |
|-------|---|---|---|---|---|
| value | 34| 25| 12| 22| 64|

第二輪，我們重複這個過程，這次只需要比較到倒數第二個元素，因為最後一個元素已經是最大的了。經過第二輪後，第二大的元素會被移動到倒數第二個位置。

| index | 0 | 1 | 2 | 3 | 4 |
|-------|---|---|---|---|---|
| value | 25| 12| 22| 34| 64|

不斷重複這個過程，直到整個數列排序完成。

時間複雜度分析：
同樣地，因為每一輪需要比較的次數會逐漸減少，總共需要比較的次數也是：
$$(n - 1) + (n - 2) + ... + 1 = \frac{n(n - 1)}{2}$$

所以時間複雜度是 $O(n^2)$。

### Using Built-in Sort Function

上述兩種排序演算法的時間複雜度都是 $O(n^2)$，在實際應用中，通常會使用程式語言內建的排序函式，這些內建函式通常使用更高效的排序演算法，例如快速排序 (Quick Sort) 或合併排序 (Merge Sort)，它們的平均時間複雜度是 $O(n \log n)$。

```kotlin
val arr = arrayOf(64, 34, 25, 12, 22)
arr.sort() // 使用 Kotlin 內建的排序函式
println(arr.joinToString(", ")) // 輸出排序後的陣列
```

上面的函數會將陣列從小到大排序，並且時間複雜度是 $O(n \log n)$。

```kotlin
val arr = arrayOf(64, 34, 25, 12, 22)
arr.sortDescending() // 使用 Kotlin 內建的排序函式，從大到小排序
println(arr.joinToString(", ")) // 輸出排序後的陣列
```

如果我們想要從大到小排序，可以使用 `sortDescending()` 函式，時間複雜度同樣是 $O(n \log n)$。

如果我們想要保留原本陣列不變，可以使用 `sorted()` 或 `sortedDescending()` 函式，這些函式會回傳一個新的排序後的陣列。

```kotlin
val arr = arrayOf(64, 34, 25, 12, 22)
val sortedArr = arr.sorted() // 回傳一個新的排序後的陣列
println(sortedArr.joinToString(", ")) // 輸出排序後的陣列
val sortedDescArr = arr.sortedDescending() // 回傳一個新的從大到小排序後的陣列
println(sortedDescArr.joinToString(", ")) // 輸出排序後的陣
```

除了 `Array` 類型之外，Kotlin 也支援對 `List` 類型跟 `ArrayList` 類型進行排序，使用方式類似。

#### 自定義
我們也可以自定義排序的條件，例如奇數在前，偶數在後：

```kotlin
val arr = arrayOf(64, 33, 25, 12, 22, 11, 90)
arr.sortWith(compareBy({ it % 2 == 0 }, { it })) // 奇數在前，偶數在後，且各自排序
println(arr.joinToString(", ")) // 輸出排序後的陣列
```

這樣會輸出 `11, 25, 33, 64, 12, 22, 90`，因為比較函數回傳 true 的時候代表要交換位置，所以奇數會被放在前面，然後再依照數字大小排序。

## 二分搜尋法 (Binary Search)

### Basic Idea

當我們要在一個陣列中尋找一個特定的數字時，我們常常會從頭到尾逐一檢查每個元素，這樣的搜尋方式稱為線性搜尋 (Linear Search)，時間複雜度是 $O(n)$，
因為在最壞的情況下，我們可能需要檢查所有的元素才能找到目標數字。

如果陣列是已經排序好的，我們可以使用二分搜尋法來提高搜尋效率。

| index | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
|-------|---|---|---|---|---|---|---|
| value | 11| 12| 22| 25| 34| 64| 90|

假設我們要尋找數字 $34$，我們可以先檢查陣列的中間元素 (index 3, value 25)，發現 $34$ 比 $25$ 大，所以我們可以排除掉左半邊的元素，因為左半邊的元素都比 $25$ 小，
接著我們只需要在右半邊的元素中繼續搜尋。

| index | 4 | 5 | 6 |
|-------|---|---|---|
| value | 34| 64| 90|

我們再次檢查中間元素 (index 5, value 64)，發現 $34$ 比 $64$ 小，所以我們可以排除掉右半邊的元素，接著我們只需要在左半邊的元素中繼續搜尋。

| index | 4 |
|-------|---|
| value | 34|

我們再次檢查中間元素 (index 4, value 34)，發現我們找到了目標數字。

因為我們每次都將搜尋範圍縮小一半，每一次搜尋的範圍是　$$\frac{n}{2^k}$$
當搜尋範圍縮小到 $1$ 時，我們就找到了目標數字，所以我們需要解決以下方程式：
$$\frac{n}{2^k} = 1$$
解出來會得到 $k = \log_2 n$，所以二分搜尋法的時間複雜度是 $O(\log n)$。

當然這裡要注意，不一定能找到目標數字，如果在搜尋過程中，搜尋範圍縮小到 $0$，代表目標數字不在陣列中。

先自己實作看看吧！寫不出來的話可以參考下面的範例程式碼。

~~~admonish info title="範例程式碼" collapsible=true
```kotlin
fun binarySearch(arr: Array<Int>, target: Int): Int {
    var left = 0
    var right = arr.size - 1

    while (left <= right) {
        val mid = left + (right - left) / 2

        when {
            arr[mid] == target -> return mid // 找到目標數字，回傳索引
            arr[mid] < target -> left = mid + 1 // 目標數字在右半邊
            else -> right = mid - 1 // 目標數字在左半邊
        }
    }

    return -1 // 目標數字不在陣列中
}
```
~~~

### 特殊二分搜

#### 尋找邊界

##### Greater Equal

有時候我們不只是要找一個數字是否存在，而是要找出符合某個條件的最佳解，例如在一個已排序的陣列中找出第一個大於等於目標數字的元素。

我們觀察一下上個問題，每個數字跟目標的關係

| index | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
|-------|---|---|---|---|---|---|---|
| value | 11| 12| 22| 25| 34| 64| 90|
| status | < | < | < | < | = | > | > |

我們找到的是 index 4 的元素 $34$，它是第一個大於等於目標數字的元素。

現在的問題變成只有兩個狀態

- 小於目標數字
- 大於等於目標數字

| index | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
|-------|---|---|---|---|---|---|---|
| value | 11| 12| 22| 25| 34| 64| 90|
| status | < | < | < | < | >= | >= | >= |

我們可以發現，當我們找到一個大於等於目標數字的元素時，我們不一定要馬上回傳它，
可以把它記錄下來，然後繼續在左半邊尋找，這樣就能找到第一個大於等於目標數字的元素。

~~~admonish info title="範例程式碼" collapsible=true
```kotlin
fun binarySearchFirstGreaterEqual(arr: Array<Int>, target: Int): Int {
    var left = 0
    var right = arr.size - 1
    var result = -1
    while (left <= right) {
        val mid = left + (right - left) / 2

        if (arr[mid] >= target) {
            result = mid // 記錄下目前找到的大於等於目標數字的索引
            right = mid - 1 // 繼續在左半邊尋找
        } else {
            left = mid + 1 // 目標數字在右半邊
        }
    }
    return result // 回傳第一個大於等於目標數字的索引
}
```
~~~

##### 伐木問題

~~~admonish note title="問題描述"
伐木工米爾科需要砍伐 $M$ 公尺的木材。這對米爾科而言是輕而易舉的任務，因為他擁有一台嶄新的電鋸，能如野火般迅速穿透森林。

然而米爾科僅被允許沿著一列的樹進行伐木。
米爾科的電鋸運作方式如下：他設定高度參數 $H$（公尺）。電鋸將巨型鋸片升至高度 $H$，並砍除所有高於 $H$ 的樹木部分，隨後米爾科會收集這些被砍下的樹木段落。

舉例而言，若一排樹木高度分別為 $20, 15, 10, 17$ 公尺，米爾科將鋸片升至 $15$ 公尺高度後，樹木殘留高度將變為 $15、15、10、15$ 公尺。米爾科將從第一棵樹獲得5公尺木材，從第四棵樹獲得2公尺木材，總計7公尺木材。

米爾科深切關注生態保育，因此絕不會過度砍伐木材。正因如此，他才將鋸片設定在最高可能位置。你的任務是協助米爾科找出鋸片高度 $H$ 的最大整數值，使他至少能獲得 $M$ 公尺木材。換言之，若將鋸片再升高一公尺，所獲木材量將低於 $M$ 公尺。
~~~

當我們的電鋸放的越低，能砍下的木材就越多；反之，當電鋸放的越高，能砍下的木材就越少，
如果用函數 $f(H)$ 來表示當電鋸高度為 $H$ 時，能砍下的木材長度，我們可以發現這是一個單調遞減的函數。

我們的目標是在這個單調遞減的函數中，找到最大的 $H$ 使得 $f(H) \geq M$。

這是不是跟我們前面介紹的「尋找第一個大於等於目標數字的元素」很像呢？
因為我們可以把 $H$ 當作陣列的 index，把 $f(H)$ 當作陣列的 value，然後我們要找的就是第一個 $f(H)$ 大於等於 $M$ 的 $H$。

像是這種具有單調性質的問題，我們就可以在每一個操作後，明確的知道結果是「大於等於目標」或是「小於目標」，然後利用二分搜尋法來尋找最佳解。

~~~admonish info title="範例程式碼" collapsible=true
```kotlin
fun woodCuttingHeights(trees: Array<Int>, M: Int): Int {
    var left = 0
    var right = trees.maxOrNull() ?: 0
    var result = 0
    while (left <= right) {
        val mid = left + (right - left) / 2
        val woodCollected = 0
        for (tree in trees) {
            if (tree > mid) {
                woodCollected += (tree - mid)
            }
        }
        if (woodCollected >= M) {
            result = mid // 記錄下目前找到的高度
            left = mid + 1 // 嘗試更高的高度
        } else {
            right = mid - 1 // 高度太高，嘗試更低的高度
        }
    }
    return result // 回傳最大高度
}
```
~~~

### Summary

- 時間複雜度是用來描述演算法在執行時所需的時間，通常會用大 $O$ 符號來表示。
- 常見的排序演算法有 Selection Sort 和 Bubble Sort，時間複雜度都是 $O(n^2)$，但實際應用中通常會使用內建的排序函式，時間複雜度是 $O(n \log n)$。
- 二分搜尋法可以在已排序的陣列中快速尋找目標數字，時間複雜度是 $O(\log n)$。
- 在具有單調性質的問題中，可以利用二分搜尋法來尋找最佳解，例如尋找第一個大於等於目標數字的元素或解決伐木問題。